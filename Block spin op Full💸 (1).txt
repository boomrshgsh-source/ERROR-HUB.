-- =========================
-- Services
-- =========================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local HttpService = game:GetService("HttpService")

-- =========================
-- Local Variables
-- =========================
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
local excludedPlayerNames = {"MithnoFs_49"}
local excludedPlayersUI = {}
-- =========================
-- Load WindUI
-- =========================
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- =========================
-- Window UI
-- =========================
local Window = WindUI:CreateWindow({
    Title = "ERROR HUB | Free | [ Demo ]",
    Icon = "",
    Author = "",
    Folder = "ERROR HUB",
    Size = UDim2.fromOffset(450, 330),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})


local ConfigManager = Window.ConfigManager
local myConfig = ConfigManager:CreateConfig("SilentAimConfig")

local SilentAimEnabled = false
local ShowFOV = true
local FOV = 120
local SilentFOVCircle
local tracerLine, targetDot

local function isPlayerExcluded(playerName)
    local lowerPlayerName = string.lower(playerName)
    for _, excludedName in ipairs(excludedPlayerNames) do
        if excludedName ~= "" and string.find(lowerPlayerName, string.lower(excludedName)) then
            return true
        end
    end
    return false
end

local function UpdateExcludedHighlights()
    for _, player in pairs(Players:GetPlayers()) do
        if isPlayerExcluded(player.Name) and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if not excludedPlayersUI[player] then
                local highlight = Instance.new("Highlight")
                highlight.FillColor = Color3.fromRGB(0, 255, 0)
                highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
                highlight.FillTransparency = 0.3
                highlight.OutlineTransparency = 0
                highlight.Parent = player.Character
                excludedPlayersUI[player] = highlight
            end
        else
            if excludedPlayersUI[player] then
                excludedPlayersUI[player]:Destroy()
                excludedPlayersUI[player] = nil
            end
        end
    end
end

-- =========================
-- FOV Circle Creation
-- =========================
local function CreateFOVCircle()
    if not isMobile then
        if SilentFOVCircle then SilentFOVCircle:Remove() end
        SilentFOVCircle = Drawing.new("Circle")
        SilentFOVCircle.Color = Color3.fromRGB(255, 255, 255)
        SilentFOVCircle.Thickness = 2
        SilentFOVCircle.NumSides = 64
        SilentFOVCircle.Filled = false
        SilentFOVCircle.Transparency = 0.8
        SilentFOVCircle.Radius = FOV
        SilentFOVCircle.Visible = SilentAimEnabled and ShowFOV
    else
        if SilentFOVCircle and SilentFOVCircle.Parent then SilentFOVCircle.Parent:Destroy() end
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "MobileFOV"
        ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
        
        SilentFOVCircle = Instance.new("Frame")
        SilentFOVCircle.Size = UDim2.fromOffset(FOV * 2, FOV * 2)
        SilentFOVCircle.AnchorPoint = Vector2.new(0.5, 0.5)
        SilentFOVCircle.Position = UDim2.fromScale(0.5, 0.5)
        SilentFOVCircle.BackgroundTransparency = 1
        
        local circleUI = Instance.new("UICorner")
        circleUI.CornerRadius = UDim.new(1, 0)
        circleUI.Parent = SilentFOVCircle
        
        local border = Instance.new("UIStroke")
        border.Color = Color3.fromRGB(255, 255, 255)
        border.Thickness = 2
        border.Transparency = 0.2
        border.Parent = SilentFOVCircle
        
        SilentFOVCircle.Parent = ScreenGui
    end
end

-- =========================
-- Drawing Objects
-- =========================
local function CreateDrawingObjects()
    if tracerLine then tracerLine:Remove() end
    if targetDot then targetDot:Remove() end
    
    tracerLine = Drawing.new("Line")
    tracerLine.Color = Color3.fromRGB(255, 50, 50)
    tracerLine.Thickness = 1
    tracerLine.Transparency = 1
    tracerLine.Visible = false
    
    targetDot = Drawing.new("Circle")
    targetDot.Color = Color3.fromRGB(255, 50, 50)
    targetDot.Thickness = 2
    targetDot.NumSides = 12
    targetDot.Radius = 4
    targetDot.Filled = true
    targetDot.Transparency = 0.7
    targetDot.Visible = false
end

-- =========================
-- Target Selection (‡∏•‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏µ‡∏£‡∏≠‡∏ö‡πÜ/‡πÉ‡∏ô‡∏£‡∏ñ)
-- =========================
local function GetClosestTarget()
    local closest = nil
    local shortestDistance = FOV
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local head = player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            
            if head and humanoid and humanoid.Health > 0 and hrp then
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local screenVector = Vector2.new(screenPos.X, screenPos.Y)
                    local distanceFromCenter = (screenVector - center).Magnitude
                    
                    if distanceFromCenter <= FOV and not isPlayerExcluded(player.Name) then
                        if distanceFromCenter < shortestDistance then
                            shortestDistance = distanceFromCenter
                            closest = player
                        end
                    end
                end
            end
        end
    end
    return closest
end

-- =========================
-- Ballistic Prediction Functions
-- =========================
local function solveQuadratic(A, B, C)
    local discriminant = B^2 - 4*A*C
    if discriminant < 0 then return nil, nil end
    local sqrtDisc = math.sqrt(discriminant)
    return (-B - sqrtDisc) / (2*A), (-B + sqrtDisc) / (2*A)
end

local function getBallisticFlightTime(direction, gravity, projectileSpeed)
    local root1, root2 = solveQuadratic(
        gravity:Dot(gravity) / 3.5,
        gravity:Dot(direction) - projectileSpeed^2,
        direction:Dot(direction)
    )
    if root1 and root2 then
        if root1 > 0 and root1 < root2 then return math.sqrt(root1) end
        if root2 > 0 and root2 < root1 then return math.sqrt(root2) end
    end
    return 0
end

local function projectileDrop(origin, target, projectileSpeed, acceleration)
    local gravity = Vector3.new(0, -acceleration * 2, 0)
    local time = getBallisticFlightTime(target - origin, gravity, projectileSpeed)
    return -0.001 * gravity * time^2
end

local function PredictPosition(origin, targetPos, approxVel, travelTime, gravity)
    local t = travelTime or 0.15 -- ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤
    return targetPos + (approxVel * t) + (targetPos - origin).Unit * t + projectileDrop(origin, targetPos, 1000, gravity or 196.2)
end

-- =========================
-- Remote Hook ‡∏¢‡∏¥‡∏á‡∏à‡∏£‡∏¥‡∏á (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Ñ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏°)
-- =========================
local Remote
pcall(function()
    Remote = ReplicatedStorage:WaitForChild("Remotes", 5):WaitForChild("Send", 5)
end)

local oldFire
if Remote and Remote.FireServer then
    local ok, res = pcall(function()
        oldFire = hookfunction(Remote.FireServer, function(self, ...)
            if self ~= Remote then return oldFire(self, ...) end
            local args = {...}

            if SilentAimEnabled and args[2] == "shoot_gun" then
                local target = GetClosestTarget()
                if target and target.Character then
                    local head = target.Character:FindFirstChild("Head")
                    local hrp = target.Character:FindFirstChild("HumanoidRootPart")
                    local humanoid = target.Character:FindFirstChild("Humanoid")

                    if head and humanoid and humanoid.Health > 0 and hrp then
                        local origin = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position
                        local aimPos = origin and PredictPosition(origin, head.Position, hrp.Velocity) or head.Position

                        -- =========================
                        -- ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Ñ‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô (‡πÄ‡∏™‡πâ‡∏ô‡∏™‡∏µ‡∏ä‡∏°‡∏û‡∏π) - ‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏•‡∏≠‡∏î‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏°
                        -- =========================
                        if origin then
                            pcall(function()
                                local part = Instance.new("Part")
                                part.Anchored = true
                                part.CanCollide = false
                                part.Size = Vector3.new(0.15, 0.15, (aimPos - origin).Magnitude)
                                part.CFrame = CFrame.new(origin, aimPos) * CFrame.new(0, 0, -part.Size.Z / 2)
                                part.Material = Enum.Material.Neon
                                part.Transparency = 0.25
                                part.Color = Color3.fromRGB(255, 0, 255) -- ‡∏ä‡∏°‡∏û‡∏π neon
                                part.Parent = Workspace
                                Debris:AddItem(part, 4)
                            end)
                        end

                        -- =========================
                        -- ‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Ñ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏¢‡∏¥‡∏á‡πÇ‡∏î‡∏ô (‡∏™‡∏µ‡πÅ‡∏î‡∏á) - ‡πÄ‡∏õ‡∏¥‡∏î‡∏ï‡∏•‡∏≠‡∏î‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏∏‡πà‡∏°
                        -- =========================
                        spawn(function()
                            wait(0.1)
                            if humanoid and humanoid.Parent and humanoid.Health > 0 then
                                local character = target.Character
                                if character then
                                    for _, part in ipairs(character:GetDescendants()) do
                                        if part:IsA("BasePart") then
                                            local box = Instance.new("Part")
                                            box.Size = part.Size + Vector3.new(0.05, 0.05, 0.05)
                                            box.CFrame = part.CFrame
                                            box.Anchored = true
                                            box.CanCollide = false
                                            box.Material = Enum.Material.Neon
                                            box.Color = Color3.fromRGB(255, 0, 0) -- ‡πÅ‡∏î‡∏á neon
                                            box.Transparency = 0.5
                                            box.Parent = Workspace
                                            local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Linear)
                                            TweenService:Create(box, tweenInfo, {Transparency = 1}):Play()
                                            Debris:AddItem(box, 2)
                                        end
                                    end
                                end
                            end
                        end)

                        args[4] = CFrame.new(
                            1/0, 1/0, 1/0,
                            0/0, 0/0, 0/0,
                            0/0, 0/0, 0/0,
                            0/0, 0/0, 0/0
                        )
                        args[5] = {
                            [1] = {
                                [1] = {
                                    ["Instance"] = head,
                                    ["Position"] = aimPos
                                }
                            }
                        }
                    end
                end
            end
            return oldFire(self, unpack(args))
        end)
    end)
    if not ok then
        warn("Warning: Failed to hook Remote.FireServer for ballistic aim")
    end
end

-- =========================
-- Main Render Loop
-- =========================
RunService.RenderStepped:Connect(function()
    pcall(function()
        local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        
        if SilentFOVCircle then
            if not isMobile then
                SilentFOVCircle.Position = center
                SilentFOVCircle.Radius = FOV
            end
            SilentFOVCircle.Visible = ShowFOV and SilentAimEnabled
        end
        
        UpdateExcludedHighlights()
        
        if not SilentAimEnabled then
            if tracerLine then tracerLine.Visible = false end
            if targetDot then targetDot.Visible = false end
            return
        end
        
        local target = GetClosestTarget()
        if target and target.Character then
            local head = target.Character:FindFirstChild("Head")
            local hrp = target.Character:FindFirstChild("HumanoidRootPart")
            local humanoid = target.Character:FindFirstChild("Humanoid")
            
            if head and humanoid and humanoid.Health > 0 and hrp then
                local origin = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position
                local aimPos = origin and PredictPosition(origin, head.Position, hrp.Velocity) or head.Position
                local screenPos, onScreen = Camera:WorldToViewportPoint(aimPos)
                
                if onScreen then
                    if tracerLine then
                        tracerLine.Visible = true
                        tracerLine.From = center
                        tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
                        tracerLine.Color = Color3.fromRGB(255, 50, 50)
                    end
                    if targetDot then
                        targetDot.Visible = true
                        targetDot.Position = Vector2.new(screenPos.X, screenPos.Y)
                    end
                else
                    if tracerLine then tracerLine.Visible = false end
                    if targetDot then targetDot.Visible = false end
                end
            else
                if tracerLine then tracerLine.Visible = false end
                if targetDot then targetDot.Visible = false end
            end
        else
            if tracerLine then tracerLine.Visible = false end
            if targetDot then targetDot.Visible = false end
        end
    end)
end)

-- =========================
-- Initial Setup
-- =========================
CreateFOVCircle()
CreateDrawingObjects()

LocalPlayer.CharacterAdded:Connect(function()
    wait(0.1)
    CreateFOVCircle()
    CreateDrawingObjects()
end)

-- =========================
-- UI Creation
-- =========================
local Tab = Window:Tab({Title = "COMBAT", Icon = "crosshair"})

local SilentToggle = Tab:Toggle({
    Title = "Silent Aim | wallbang ",
    Desc = "‡∏•‡πá‡∏≠‡∏Ñ‡∏´‡∏±‡∏ß‡∏Å‡∏±‡∏ö‡∏¢‡∏¥‡∏á‡∏ó‡∏∞‡∏•‡∏∏",
    Default = false,
    Callback = function(state)
        SilentAimEnabled = state
    end
})
myConfig:Register("SilentAim", SilentToggle)

local FOVSlider = Tab:Slider({
    Title = "FOV: ",
    Step = 1,
    Value = {Min = 20, Max = 750, Default = FOV},
    Callback = function(value)
        FOV = tonumber(value) or 120
        if SilentFOVCircle then
            if isMobile then
                SilentFOVCircle.Size = UDim2.fromOffset(FOV * 2, FOV * 2)
            else
                SilentFOVCircle.Radius = FOV
            end
        end
    end
})
myConfig:Register("FOVRadius", FOVSlider)

local ShowFOVToggle = Tab:Toggle({
    Title = "Show FOV",
    Desc = "‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏áFOV",
    Default = ShowFOV,
    Callback = function(state)
        ShowFOV = state
        if SilentFOVCircle then
            SilentFOVCircle.Visible = state and SilentAimEnabled
        end
    end
})
myConfig:Register("ShowFOV", ShowFOVToggle)

Tab:Divider()

local FriendsInput = Tab:Input({
    Title = "Safe Friend List",
    Desc = "Enter Player Name",
    Value = "",
    InputIcon = "shield-check",
    Type = "Input",
    Placeholder = "",
    Callback = function(input)
        excludedPlayerNames = {}
        for name in string.gmatch(input, "%S+") do
            table.insert(excludedPlayerNames, name)
        end
        for _, player in pairs(Players:GetPlayers()) do
            if espPlayers and espPlayers[player] and espPlayers[player].drawings then
                local nameText = espPlayers[player].drawings[1]
                nameText.Color = isPlayerExcluded(player.Name) and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,255,255)
            end
        end
    end
})
myConfig:Register("FriendsList", FriendsInput)

Players.PlayerAdded:Connect(UpdateExcludedHighlights)
Players.PlayerRemoving:Connect(function(player)
    if excludedPlayersUI[player] then
        excludedPlayersUI[player]:Destroy()
        excludedPlayersUI[player] = nil
    end
end)


local PlayerTab = Window:Tab({Title = "Player", Icon = "üèÉ"})

local Net = {}
function Net.send(...)
    local args = {...}
    CounterTable.event = CounterTable.event + 1
    pcall(
        function()
            Remotes.Send:FireServer(CounterTable.event, unpack(args))
        end
    )
end

local AutoSprintToggle =
    PlayerTab:Toggle(
    {
        Title = "Infinite Stamina",
        Default = false,
        Callback = function(state)
            AutoSprintEnabled = state
            if AutoSprintEnabled then
                -- Override stamina update to prevent depletion
                local success, SprintModule =
                    pcall(
                    function()
                        return require(ReplicatedStorage.Modules.Game.Sprint)
                    end
                )
                if success and SprintModule then
                    local consume_stamina = SprintModule.consume_stamina
                    local SprintBar = getupvalue(consume_stamina, 2).sprint_bar
                    if SprintBar then
                        local Old = SprintBar.update
                        SprintBar.update = function(...)
                            return Old(
                                function()
                                    return 1
                                end
                            ) -- Keep stamina at full
                        end
                        -- Store original function for restoration
                        getgenv().OriginalSprintUpdate = Old
                        -- Start auto sprint loop
                        getgenv().AutoSprintLoop =
                            task.spawn(
                            function()
                                while AutoSprintEnabled do
                                    pcall(
                                        function()
                                            Net.send("set_sprinting_1", true)
                                            task.wait(0.5)
                                            Net.send("set_sprinting_1", false)
                                        end
                                    )
                                    task.wait(0.1) -- Prevent excessive CPU usage
                                end
                                -- Ensure sprint is disabled when loop ends
                                pcall(
                                    function()
                                        Net.send("set_sprinting_1", false)
                                    end
                                )
                            end
                        )
                        if WindUI then
                            WindUI:Notify(
                                {
                                    Title = "‚úÖ INF STAMINA",
                                    Description = "Infinite Stamina ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß",
                                    Duration = 3
                                }
                            )
                        end
                    else
                        warn("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö SprintBar!")
                        AutoSprintEnabled = false
                        AutoSprintToggle:Set(false)
                    end
                else
                    warn("‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î SprintModule ‡πÑ‡∏î‡πâ!")
                    AutoSprintEnabled = false
                    AutoSprintToggle:Set(false)
                end
            else
                -- Stop sprint loop and restore stamina behavior
                if getgenv().AutoSprintLoop then
                    task.cancel(getgenv().AutoSprintLoop)
                    getgenv().AutoSprintLoop = nil
                end
                -- Ensure sprint is disabled
                pcall(
                    function()
                        Net.send("set_sprinting_1", false)
                    end
                )
                -- Restore original stamina update function
                local success, SprintModule =
                    pcall(
                    function()
                        return require(ReplicatedStorage.Modules.Game.Sprint)
                    end
                )
                if success and SprintModule then
                    local consume_stamina = SprintModule.consume_stamina
                    local SprintBar = getupvalue(consume_stamina, 2).sprint_bar
                    if SprintBar and getgenv().OriginalSprintUpdate then
                        SprintBar.update = getgenv().OriginalSprintUpdate
                        getgenv().OriginalSprintUpdate = nil
                    end
                end
                if WindUI then
                    WindUI:Notify(
                        {
                            Title = "‚ùå Auto Sprint Disabled",
                            Description = "Infinite Stamina ‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß",
                            Duration = 3
                        }
                    )
                end
            end
        end
    }
)
myConfig:Register("AutoSprint", AutoSprintToggle)
